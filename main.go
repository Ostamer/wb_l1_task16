package main

import "fmt"

// Быстрая сортировка
func quickSort(arr []int) []int {
	if len(arr) <= 1 {
		return arr // Если длина массива меньше или равна 1, возвращаем этот масив
	}

	pivot := arr[len(arr)-1] // Выбираем последний элемент как опорный

	left := []int{}  // Левый подмассив
	right := []int{} // Правый подмассив

	// Разделяем элементы на два массива меньше опорного и больше опорного элемента
	for _, v := range arr[:len(arr)-1] {
		if v < pivot {
			left = append(left, v)
		} else {
			right = append(right, v)
		}
	}

	// Рекурсивно сортируем левую и правую часть
	left = quickSort(left)
	right = quickSort(right)

	// Возвращаем объединенный отсортированный массив
	return append(append(left, pivot), right...)
}

// Суть алгоритма в том чтобы делить исходны массив на левую и правую часть и рекурсивно их вызывать до тех пор пока не останется по одному элементу и возвращать их,
// тем самым благодаря стеку вызовов мы будем получать отсортированный массив. Алгоритмеческая сложность O(n*log(n))
// Просто интересная заметка, самые быстрые алгоритмы сортировкой такие как сортировка кучей, пирамидальная сортировка и быстрая сортировка,
// отрабатывают за лучшее время O(n*log(n)), а сортировка пузырьком за O(n), так что если вы слишком везучий человек то можно попытать удачу)))

func main() {
	arr := []int{5412, 432, 545, 687765, 5347, 763, 329, 15431, 231, 8524}
	fmt.Println("Исходный список:", arr)

	sortedArr := quickSort(arr)
	fmt.Println("Отсортированный список:", sortedArr)
}
